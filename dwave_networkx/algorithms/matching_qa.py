"""
TODO
"""
import sys
import itertools

from collections import defaultdict

from dwave_networkx.utils_qa.decorators import quantum_annealer_solver

__all__ = ['maximal_matching']

# compatibility for python 2/3
if sys.version_info[0] == 2:
    range = xrange
    iteritems = lambda d: d.iteritems()
else:
    iteritems = lambda d: d.items()


@quantum_annealer_solver(1)
def maximal_matching(G, solver, **solver_args):
    """TODO"""

    # the maximum degree
    delta = max(G.degree(node) for node in G)

# @quantum_annealer_solver(1)
# def minimal_maximal_matching(G, solver, **solver_args):
#     """
#     TODO
#     """

#     delta = max(G.degree(node) for node in G)

#     A = 1.  # we want this to be a float
#     if delta == 2:
#         B = .75 * A
#     else:
#         B = .75 * A / (delta - 2.)
#     C = .75 * B

#     # For each edge e in G, we define a binary variable v_e which is 1 when e is in the matching,
#     # and 0 otherwise.
#     qubo_variables = {edge: idx for idx, edge in enumerate(G.edges_iter())}
#     qubo_variables.update({(n1, n0): idx for (n0, n1), idx in iteritems(qubo_variables)})

#     # the first condition we which to enforce, is we wish no node to have two colored edges
#     Q = _matching_qubo(G, edge_mapping=qubo_variables, magnitude=A)

#     # now some magic that I have no idea how to explain
#     for node in G:
#         for edge in G.edges_iter(node):
#             v = qubo_variables[edge]
#             if (v, v) not in Q:
#                 Q[(v, v)] = B * G.degree(node)
#             else:
#                 Q[(v, v)] += B * G.degree(node)

#     for n0, n1 in G.edges_iter():
#         for e in G.edges_iter(n0):
#             ve = qubo_variables[e]
#             for d in G.edges_iter(n1):
#                 vd = qubo_variables[d]

#                 if (ve, vd) not in Q:
#                     Q[(ve, vd)] = B
#                 else:
#                     Q[(ve, vd)] += B

#     # finally we want to color as few edges as possible
#     for edge in G.edges_iter():
#         v = qubo_variables[edge]
#         Q[(v, v)] += C

#     # we expect that the solution will be a dict of the form {node: int(bool)}
#     response = solver.sample_qubo(Q, **solver_args)

#     # we want the lowest energy sample
#     solution = next(response.samples())

#     return set(edge for edge in G.edges_iter() if solution[qubo_variables[edge]] > 0)


def is_matching(matching):
    """TODO"""
    return len(set().union(*matching)) == len(matching) * 2


def is_maximal_matching(G, matching):
    """TODO"""
    touched_nodes = set().union(*matching)

    # first check if a matching
    if len(touched_nodes) != len(matching) * 2:
        return False

    # now for each edge, check that at least one of its variables is
    # already in the matching
    for (u, v) in G.edges_iter():
        if u not in touched_nodes and v not in touched_nodes:
            return False

    return True


def _maximal_matching_qubo(G, edge_mapping, magnitude=1.):
    """Generates a QUBO that when combined with one as generated by _matching_qubo,
    induces a maximal matching on the given graph G.
    The variables in the QUBO are the edges, as given my edge_mapping.

    ground_energy = -1 * magnitude * |edges|
    infeasible_gap >= magnitude
    """
    Q = defaultdict(float)

    # for each node n in G, define a variable y_n to be 1 when n has a colored edge
    # and 0 otherwise.
    # for each edge (u, v) in the graph we want to enforce y_u OR y_v. This is because
    # if both y_u == 0 and y_v == 0, then we could add (u, v) to the matching.
    for (u, v) in G.edges_iter():
        # 1 - y_v - y_u + y_v*y_u

        # for each edge connected to u
        for edge in G.edges_iter(u):
            x = edge_mapping[edge]
            Q[(x, x)] -= magnitude

        # for each edge connected to v
        for edge in G.edges_iter(v):
            x = edge_mapping[edge]
            Q[(x, x)] -= magnitude

        for e0 in G.edges_iter(v):
            x0 = edge_mapping[e0]
            for e1 in G.edges_iter(u):
                x1 = edge_mapping[e1]

                if x0 < x1:
                    Q[(x0, x1)] += magnitude
                else:
                    Q[(x1, x0)] += magnitude

    return dict(Q)


def _matching_qubo(G, edge_mapping, magnitude=1.):
    """Generates a QUBO that induces a matching on the given graph G.
    The variables in the QUBO are the edges, as given my edge_mapping.

    ground_energy = 0
    infeasible_gap = magnitude
    """
    Q = {}

    # We wish to enforce the behaviour that no node has two colored edges
    for node in G:

        # for each pair of edges that contain node
        for edge0, edge1 in itertools.combinations(G.edges_iter(node), 2):

            v0 = edge_mapping[edge0]
            v1 = edge_mapping[edge1]

            # penalize both begin True
            Q[(v0, v1)] = magnitude

    return Q
